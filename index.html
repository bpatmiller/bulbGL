<!DOCTYPE html>
<html >
<head>
  <meta charset="UTF-8">
  <title>webgl</title>
  <style type="text/css">
      body {
        padding:0px;
        margin:0px;
        overflow: hidden;
        background-color: black;
      }
    </style>
    <script src="dat.gui.min.js"></script>
</head>
<body>
  <div id="container"></div>
  <script id="vertexShader" type="x-shader/x-vertex">

    void main() {
      gl_Position = vec4( position, 1.0 );
    }

  </script>

  <script id="fragmentShader" type="x-shader/x-fragment">

    uniform vec2 iResolution;
    uniform float iGlobalTime;
    
    const int maxRaySteps = 20;
    uniform float minimumStepDistance;


    float bailout = 8.0;
    float power = 8.0;
    const int iterations = 8;
    const int colorIters = 8;
    float zoom = 1.0;

    //uniform vec3 cameraData;
    uniform vec3 camera;
    uniform vec3 focus;
    vec3 light = vec3(0.0,0.0,5.0);

    vec3 hsv2rgb(vec3 c) {
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }

    vec3 toRectangular(vec3 sph) {
        return vec3(sph.x*sin(sph.z)*cos(sph.y),
                    sph.x*sin(sph.z)*sin(sph.y),
                    sph.x*cos(sph.z));
    }

    vec3 toSpherical(vec3 rec) {
        return vec3(length(rec),
                    atan(rec.y,rec.x),
                    atan(sqrt(rec.x*rec.x+rec.y*rec.y),
                    rec.z));
    }

    float escape(vec3 position) {
      vec3 z = position;
        float r = 0.0;
        float theta,phi,zr;
        int ii;
        for(int i=0;i<colorIters;i++) {
          ii=i;
          r = length(z);
            if(r>bailout) break;
            
            theta = power*atan(sqrt(z.x*z.x+z.y*z.y),z.z);
            phi = power*atan(z.y,z.x);
            zr = pow(r,power);
        z = vec3( zr*sin(theta)*cos(phi) + position.x,
                      zr*sin(phi)*sin(theta) + position.y,
                      zr*cos(theta) + position.z     );
        }
        //return float(i) + log(log(r*r))/log(2.0) - log(log(dot(z,z)))/log(2.0);
        return sin(float(ii)/4.0);

}

    float DE(vec3 position) {
      vec3 z = position;
        float dr = 1.0;
        float r = 0.0;
        float theta,phi,zr;
        for(int i=0;i<iterations;i++) {
          r = length(z);
            if(r>bailout) break;
            
            theta = power*atan(sqrt(z.x*z.x+z.y*z.y),z.z);
            phi = power*atan(z.y,z.x);
            zr = pow(r,power);
        z = vec3(     zr*sin(theta)*cos(phi) + position.x,
                      zr*sin(phi)*sin(theta) + position.y,
                      zr*cos(theta) + position.z     );
          dr = ( pow(r, power-1.0)*power*dr ) + 1.0;        
        }
        return 0.5*log(r)*r/dr;
    }

    vec3 march(vec3 from, vec3 direction) {
      float totalDistance = 0.0;
        float dist;
        vec3 position;
        int steps;
        for (int steps=0;steps<maxRaySteps;steps++) {
            position = vec3(from.x + (direction.x*totalDistance),
                            from.y + (direction.y*totalDistance),
                            from.z + (direction.z*totalDistance));
            dist=DE(position);
            totalDistance+=dist;
	    if(totalDistance>6.0) return vec3(0.0,0.0,0.0);
            if(dist<minimumStepDistance) {
              return vec3(escape(position),0.6,1.0-float(steps)/float(maxRaySteps));
            }
      }
    }

    void main(void) {
        //uv is between 0 and 1
        vec2 uv = gl_FragCoord.xy / iResolution.xy;
        // animate through powers
        power = 8.0 + 6.0*sin(iGlobalTime/6.0);
        // compute raymarching vectors
        vec3 viewVector = focus - camera;
        vec3 topVector = toSpherical(viewVector);
        topVector.z += 1.5708;
        topVector = toRectangular(topVector);
        vec3 sideVector = cross(viewVector,topVector);
        sideVector = normalize(sideVector)*length(topVector);
        //
        float dx = zoom*(uv.x - 0.5);
        float dy = (-1.0)*zoom*(uv.y - 0.5)*(iResolution.y/iResolution.x);

        vec3 direction = normalize((sideVector*dx) + (topVector*dy) + viewVector);

        gl_FragColor = vec4(hsv2rgb(march(camera,direction)),1.0);
    }

  </script>

  <script src='https://threejs.org/build/three.min.js'></script>
  <script src="script.js"></script>
</body>
</html>
